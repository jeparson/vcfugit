---
title: "VCFTable"
author: "Jerod Parsons"
date: "August 1, 2016"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---
## Variant information for the provided VCF file
```{r Setup}
knitr::opts_chunk$set(tidy=TRUE)
```
```{r PackageInstallation}
# Package installation section: Install required packages
biocpackages<-c("VariantAnnotation","GenomicFeatures","biomaRt",
                "BSgenome.Hsapiens.UCSC.hg19","TxDb.Hsapiens.UCSC.hg19.knownGene")
cranpackages<-c("data.table","shiny")
if(sum(!biocpackages%in%installed.packages())>0){
  source("https://bioconductor.org/biocLite.R")
  biocLite(biocpackages[!biocpackages%in%installed.packages()])}
if(sum(!cranpackages%in%installed.packages())>0){
  install.packages(cranpackages[!cranpackages%in%installed.packages()])
}
suppressPackageStartupMessages({  library("VariantAnnotation")
  library("GenomicFeatures")
  library("biomaRt")
  library("data.table")
  library("BSgenome.Hsapiens.UCSC.hg19")
})
```
Because these bioconductor packages most easily use the hg19 genome and this vcf was mapped to grch37, some genomic coordinates 
do not match.  NA's in the table below show how many variants were unable to be located on the hg19 reference.
```{r DefineDataset}
buildvcftable<-function(vcffile,genome){
  if(is.null(vcffile)){return(0)}
  vcf<-readVcf(vcffile,genome = genome)
# Consider speeding up the vcf read by using ScanVcfParam 
# Although that may cause issues with predictCoding and locateVariants
  switch(genome,
         'hg19'=library("TxDb.Hsapiens.UCSC.hg19.knownGene"),
         stop("Unsupported genome ",genome))
# Currently only supporting HG19 because unfortunately that's what all of the TxDbs support.
# It comes at the cost of interpretation of the mitochondria and other non-chromosomal sequences in grch37/38 data.
  
# Determine Type of variation 
  seqlevelsStyle(vcf)<-"UCSC"
  all <- suppressWarnings(suppressMessages(locateVariants(vcf, TxDb.Hsapiens.UCSC.hg19.knownGene, AllVariants()))) # Genomic location of variant
  mcols(all)$LOCATION<-gdata::reorder.factor(mcols(all)$LOCATION,new.order=c("intergenic","intron","threeUTR","fiveUTR","promoter","spliceSite","coding")) # Re-order the levels of the factor in order of least to most detrimental, so i can just use 'max' to return the most deleterious
  variants<-split(mcols(all)$LOCATION,mcols(all)$QUERYID)
  maxfactor<-function(input){
    # Input:  Factor of locations.  Factor must be ordered such that the last level is 'worst'
    # Return:  The highest level present in the factor
  levels(input)[max(as.numeric(input))]
}
varl <- lapply(variants,maxfactor) # Now a list of variants and the worst location
varl <- data.frame(pos=names(varl),var=unlist(varl))
cdiff <- predictCoding(vcf,TxDb.Hsapiens.UCSC.hg19.knownGene,Hsapiens) # Now to see how detrimental those various coding variants are
conseq <- split(mcols(cdiff)$CONSEQUENCE,mcols(cdiff)$QUERYID)
mcols(cdiff)$CONSEQUENCE<-gdata::reorder.factor(mcols(cdiff)$CONSEQUENCE,new.order=c("frameshift","nonsense","nonsynomyous","synonymous"))
conseql <- lapply(conseq,maxfactor)
conseql <- data.frame(pos=names(conseql),var=unlist(conseql))
# Now merge together the locations & consequences
Variants <- data.frame(pos=1:length(vcf))
varl$var <- factor(varl$var,levels=c(levels(varl$var),"frameshift","nonsense","nonsynonymous","synonymous")) #allow me to add the new consequences into the same factor list
if(length(conseql$var) == sum(varl$var=="coding")){
  varl$var[varl$var=="coding"]<-conseql$var
}# A quick test that nothing went wrong, and an overwrite of "coding" to its various subtypes
Variants <- merge(Variants,varl,by="pos",all="TRUE")
# Depth of coverage @ position
outdf<-data.frame(info(vcf)[c("TR","TC")])
# Number of reads supporting variant
outdf$TR <- unlist(lapply(outdf$TR, `[[`, 1)) # The TR field is a list of integerlists, we just want the 1st element.  This causes technically incorrect results in 15/11765 test cases.
# Percent of reads supporting variant
outdf$ReadPct <- round(outdf$TR/outdf$TC,digits = 3)*100
# Also relevant information: Filter Status:
Filter=mcols(vcf)["FILTER"]
vcftable<-data.table(Variant=rownames(outdf),VarType=Variants$var,Depth=outdf$TC,SupportingReads=outdf$TR,PercentSupport=outdf$ReadPct,Filter=Filter$FILTER)
return(vcftable)
}
vcftable<-buildvcftable(vcffile="~/Downloads/test_vcf_data.vcf",genome="hg19")
vcftable$VarType<-droplevels(vcftable$VarType)
summary((vcftable$VarType)) 
textInput('filename',label="filename to save to",value="test.csv")
actionButton('go','Save!')
output<-renderText(expr = function(){
  input$go
  return("File Saved")})
textOutput("output")
observeEvent(input$go,
  write.csv(x = vcftable,file=input$filename,quote=FALSE,row.names = FALSE))
renderDataTable(vcftable)
```
